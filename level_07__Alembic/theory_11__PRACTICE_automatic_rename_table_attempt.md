## Попытка переименования таблицы с помощью автоматической миграции

### Задача

Попробуем сделать обратное переименование: `account` в `user`.

### 1. В ORM-модели изменяем имя таблицы

```python
__tablename__ = "user"
```

### 2. Создаём автоматически сгенерированную миграцию

```bash
alembic revision --autogenerate -m "rename account back to user"
```

События в логе:

```
alembic revision --autogenerate -m "rename account back to user"
INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO  [alembic.runtime.migration] Will assume transactional DDL.
INFO  [alembic.autogenerate.compare] Detected added table 'user'
INFO  [alembic.ddl.postgresql] Detected sequence named 'user_id_seq' as owned by integer column 'account(id)', assuming SERIAL and omitting
INFO  [alembic.autogenerate.compare] Detected removed table 'account'
  Generating /home/su/PythonProjects/JavaRashAlembicSQLAlchemy/alembic/versions/b43bfe3a4d5d_rename_account_back_to_user.py ...  done
```

### 3. Проверяем автоматически сгенерированную миграцию

```python
def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('user',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(), nullable=False),
    sa.Column('age', sa.Integer(), nullable=False),
    sa.Column('email', sa.String(), nullable=False),
    sa.Column('city', sa.String(length=100), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('email')
    )
    op.drop_table('account')
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('account',
    sa.Column('id', sa.INTEGER(), autoincrement=True, nullable=False),
    sa.Column('name', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('age', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('email', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('city', sa.VARCHAR(length=100), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('id', name=op.f('user_pkey')),
    sa.UniqueConstraint('email', name=op.f('user_email_key'), postgresql_include=[], postgresql_nulls_not_distinct=False)
    )
    op.drop_table('user')
    # ### end Alembic commands ###

```

Как видим, вместо переименования предложено **drop + create**.

❗ И это **ожидаемое поведение**.

---

### Почему Alembic так делает?

#### Ключевая идея

> **Alembic не знает, что таблицы — это «та же самая сущность»**

Alembic:

* сравнивает **metadata ORM**
* с **фактической схемой БД**
* **по имени объектов**, а не по смыслу

Он видит:

| Было в БД | Есть в моделях |
| --------- | -------------- |
| `account` | ❌              |
| ❌         | `user`         |

И делает логичный (но наивный) вывод:

> «Таблицу `account` удалили, а `user` создали заново»

---

#### Почему Alembic НЕ может догадаться о rename

Потому что:

* rename **не хранится** в metadata
* нет идентификаторов таблиц
* нет истории соответствий имён

Для Alembic это **две разные таблицы**.

---

#### ❌ Почему нельзя принимать autogenerate как есть

Если вы оставите:

```python
op.drop_table('account')
op.create_table('user', ...)
```

На проде это означает:

❌ удаление данных  
❌ потерю FK  
❌ потерю индексов  
❌ downtime  

Это **катастрофа**, а не миграция.

---

#### Как правильно поступить (канонический способ)?

##### Шаг 1. Разрешаем Alembic «ошибиться»

Вы **запускаете autogenerate**, но **НЕ принимаете его вывод**.

```bash
alembic revision --autogenerate -m "rename account back to user"
```

---

##### Шаг 2. ВРУЧНУЮ правим миграцию

❌ Было (autogen, неправильно):

```python
def upgrade():
    op.create_table('user', ...)
    op.drop_table('account')
```

---

✅ Должно быть (правильно):

```python
from alembic import op


def upgrade() -> None:
    op.rename_table('account', 'user')


def downgrade() -> None:
    op.rename_table('user', 'account')
```

---

## Шаг 3. Применяем миграцию

```bash
alembic upgrade head
```

✔ данные сохранены
✔ операция мгновенная
✔ Alembic «доволен»

---

### Очень важное правило Alembic

> **Autogenerate — это не истина, а подсказка**

Вы обязаны:

* читать каждую миграцию
* понимать SQL, который она вызовет
* **исправлять rename вручную**

---

### Можно ли "научить" Alembic «учат» переименовывать, а не пересоздавать?

Теоретически можно:

* использовать `alembic.op.f()` с кастомными naming conventions
* писать кастомные сравниватели
* хранить mapping имён

На практике **никто этого не делает**.

В реальных проектах:

* rename всегда **ручной**
* autogenerate используется только как детектор изменений

