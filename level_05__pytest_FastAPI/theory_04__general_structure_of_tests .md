## 1. Цели тестирования

Наш проект разделён на три уровня:

1. **HTTP-маршруты (Routes)** — обработка запросов, валидация, HTTP-ответы.
2. **Репозиторий (Repository)** — логика работы с данными.
3. **База данных (Database)** — реальный SQLAlchemy + PostgreSQL/SQLite.

Поэтому тесты разделены так, чтобы каждый уровень проверялся **изолированно**.

---

## 2. `conftest.py` — инфраструктура тестирования

`conftest.py` — это технический файл, обеспечивающий:

### ✔ фикстуры FastAPI `async_client`

Создаёт тестовый HTTP-клиент.

### ✔ фикстуры SQLAlchemy (две версии)

1. **Фейковая DB (In-Memory SQLite / transaction rollback)** — для мок-тестов репозитория и эндпоинтов.
2. **Реальная DB (без моков)** — для интеграционных тестов.

### ✔ общие тестовые данные (`book_data`, `created_book`)

Эти фикстуры позволяют:

* избегать дублирования в тестах,
* точно контролировать окружение,
* запускать тесты параллельно и независимо.

---

##  3. `test_routes.py` — тестирование эндпойнтов без реальной БД

Задача:

### Протестировать веб-слой (маршруты FastAPI) без реальной базы

Используем:

* Мок-сессии SQLAlchemy (in-memory / transaction rollback)
* Тестовый FastAPI-клиент
* Фикстуру `create_book`, которая создаёт книгу через API

Принципы мокинга:

* Данные не сохраняются между тестами.
* Каждый тест выполняется в своей транзакции.
* Репозиторий фактически работает, но таблицы создаются в SQLite in-memory.
* Это позволяет протестировать:

  * работу HTTP-методов,
  * статусы и структуру ответов,
  * взаимодействие маршрута с репозиторием,
  * валидацию схем.

Но мы **не тестируем реальную БД**, индексы и ограничения.

То есть:

> Это быстрые тесты веб-слоя без накладных расходов реальной базы.

---

## 4. `test_repository_db.py` — юнит-тесты репозитория

Задача:

### Протестировать repository в изоляции от FastAPI и HTTP

Принципы:

* Используем мок-сессию SQLAlchemy: сессия создаётся в фикстуре, транзакция откатывается.
* Тестируем только методы репозитория:

  * `create_book`
  * `get_book`
  * `update_book`
  * `delete_book`
  * `list_books`
* Не тестируем HTTP-коды, схемы запросов, маршруты.
* На этом уровне репозиторий — обычный Python-класс, которому нужна лишь session.

То есть:

> Репозиторий тестируется как независимый слой бизнес-логики.

---

## 5. `test_routes_db.py` — интеграционные тесты с настоящей БД

Задача:

### Проверить систему целиком: FastAPI → Репозиторий → SQLAlchemy → Реальная БД

Особенности:

* Используется реальный созданный движок SQLAlchemy (обычно SQLite в файле или PostgreSQL в контейнере).
* Таблицы создаются миграциями или декларативными моделями.
* Данные сохраняются реально (внутри фикстуры всё чистится).

В этих тестах мы проверяем:

* корректность SQL-запросов (JOIN, индексы, уникальные ограничения),
* реальные транзакции,
* поведение приложения в натуральной среде.

Это более медленные тесты, но они гарантируют, что:

> Весь стек работает правильно и фактические SQL-запросы корректны.

---

# 6. Что покрывают все тесты вместе?

| Уровень              | Файл                      | Что проверяем                                  |
| -------------------- | ------------------------- | ---------------------------------------------- |
| Юнит                 | **test_repository_db.py** | Только Python-логику репозитория               |
| HTTP-логика          | **test_routes.py**        | Маршруты, HTTP-коды, схемы, но без реальной БД |
| Интеграция           | **test_routes_db.py**     | Работа FastAPI + SQLAlchemy + реальная БД      |
| Технические фикстуры | **conftest.py**           | Клиенты, БД, мок-сессии, тестовые данные       |

---

# 7. Принципы мокинга без БД

Когда мы тестируем эндпойнты без реальной базы:

1. Используем SQLite in-memory (`sqlite+aiosqlite:///:memory:`)
2. Оборачиваем каждый тест в транзакцию
3. После теста транзакция откатывается
4. Ничего не сохраняется между тестами

То есть:

> Моки позволяют быстро тестировать, но не гарантируют реальную работу SQL-запросов.

---

# 8. Принципы интеграционного тестирования

1. Используем реальный движок SQLAlchemy (SQLite/PostgreSQL)
2. Таблицы создаются настоящими миграциями или ORM-моделями
3. Данные реально записываются и читаются
4. Тестируется весь путь HTTP-запроса

Это полезно, потому что:

* SQLite in-memory ведёт себя иначе, чем PostgreSQL
* ограничения UNIQUE, FK и индексы работают по-настоящему
* SQLAlchemy может генерировать разные SQL для разных движков

