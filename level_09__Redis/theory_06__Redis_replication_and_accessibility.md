Этот блок посвящен механизмам, обеспечивающим отказоустойчивость и непрерывность работы Redis.  
Основной акцент сделан:
* на репликации как базовом механизме,
* и инструментах для автоматического `failover` (переключения на резерв). 

---

### Репликация и высокая доступность `HA` (`High Availability`) в Redis

#### 1. Мастер-реплика репликация (Primary-Replica Replication)

   - **Модель лидер-подчиненный (`primary-replica`)**: 
     - Репликация в Redis следует async (по умолчанию) модели primary-replica. 
     - Primary (мастер) принимает записи, 
     - а replicas (реплики) копируют данные от него в одном направлении. 
     - Реплики read-only и используются для масштабирования чтения или как резерв для `failover`.
   
   - **Процесс синхронизации**:
     - 1. Полная синхронизация: 
       - При подключении реплика 
         - запрашивает снимок (RDB) от primary, 
         - загружает его 
         - и затем получает инкрементальные обновления.
         
     - 2. Частичная синхронизация (`PSYNC`): 
       - `PSYNC` — это механизм Redis, при котором реплика (после временного разрыва соединения)
         - продолжает репликацию с того места, где остановилась, 
           - используя для этого сохранённый оффсет (записи в логах)
         - вместо того чтобы заново загружать всю базу данных. 
       - Это делает репликацию быстрее и эффективнее, начиная с Redis 2.8.
       
       - **Частичная синхронизация (`PSYNC`) невозможна**, если:
         - `backlog` слишком мал и нужные данные уже потеряны
         - мастер был перезапущен (сменился `replid`)
         - реплика слишком долго была отключена
         
     - 3. В Redis 8+: 
       - Улучшенный механизм репликации 
         - снижает пиковую нагрузку на буфер на 35% 
         - и ускоряет процесс на 18%.
         
   - **Конфигурация**: 
     - На реплике указывается `replicaof <primary_ip> <primary_port>`. 
     - Поддержка нескольких реплик от одного primary.
     
   - **Преимущества и ограничения**: 
     - Увеличивает доступность чтения 
     - и защищает от потери данных при отказе primary 
     - (но асинхронность может привести к потере последних записей). 
     - Нет автоматического `failover` — требуется внешний инструмент.
     
   - **Python-контекст**: 
     - В redis-py реплики подключаются напрямую (Redis(host=replica_ip)), 
     - но для HA (`High Availability`) лучше использовать Sentinel или Cluster.
       - (когда в кластере есть primary сервер и несколько replicas)

#### 2. Redis Sentinel: Система высокой доступности для primary-replica

   - **Назначение**: 
     - Sentinel — отдельная система мониторинга и автоматического failover для setups без шардинга. 
     - Обеспечивает HA (`High Availability`), когда не используется Redis Cluster.
     
   - **Ключевые функции**:
     - Мониторинг: 
       - Постоянная проверка работоспособности primary и реплик.
       
     - Обнаружение сбоев: 
       - Субъективная (`SDOWN`) и объективная (`ODOWN`) недоступность. 
         - субъективная — локальное подозрение
         - объективная — подтверждённый отказ
         
       - Failover запускается при кворуме (`quorum`) — согласии большинства Sentinel'ов.
       
     - Автоматический failover: 
       - Выбор реплики с наиболее актуальными данными, промоушен в primary, переконфигурация остальных реплик.
       
     - Уведомления и сервис-дискавери: 
       - Клиенты запрашивают у Sentinel текущий primary.
       
   - **Конфигурация**: 
     - Минимум 3 Sentinel'а (нечетное число для кворума). 
     - Параметры: 
       - `sentinel monitor <master-name> <ip> <port> <quorum>`, 
       - down-after-milliseconds, 
       - failover-timeout.
       
   - **Ограничения**: 
     - Не поддерживает шардинг (все данные на одном primary), 
     - подходит для moderate нагрузок. 
     - В случае network partition — eventual consistency.
     - 
   - **Python-перспектива**: 
     - В redis-py встроенная поддержка Sentinel. 
     - Создается объект Sentinel с списком sentinel-нод, 
     - затем master_for('master-name') для записи и slave_for() для чтения. 
     - Клиент автоматически обнаруживает новый primary после failover.

#### 3. Связь с CAP-теоремой и consistency

   - Redis фокусируется на **AP** (Availability + Partition tolerance) из CAP: 
     - Приоритет — доступность и толерантность к разделению сети.
     
   - Асинхронная репликация обеспечивает высокую доступность, но слабую consistency (eventual consistency). 
     - Возможна потеря данных при failover (последние записи не реплицированы).
     
   - Команда WAIT: 
     - Блокирует клиента до подтверждения записи заданным числом реплик (синхронный режим частично).
     
   - В production: 
     - Комбинировать с персистентностью (AOF) для минимизации потерь.

#### 4. Сравнение Sentinel и Redis Cluster в контексте HA (`High Availability`)

   - **Sentinel**: 
     - Для HA без масштабирования данных. 
     - Простота, низкие требования.
     - Идеально для кэша/сессий с moderate размером данных.
     
   - **Redis Cluster**: 
     - Встроенная HA + горизонтальное масштабирование (шардинг по 16384 слотам). 
     - Автоматический failover внутри кластера, но сложнее (минимум 6 нод: 3 primary + 3 replica). 
     - Подходит для больших датасетов.
     
   - **Python-интеграция**: 
     - Для Cluster — RedisCluster в redis-py, с автоматической обработкой редиректов (MOVED/ASK).

#### 5. Лучшие практики для высокой доступности

   - Размещать primary и реплики в разных зонах/регионах (multi-zone).
   - Использовать нечетное число нод для избежания split-brain.
   - Мониторинг: 
     - INFO replication, Sentinel commands.
   - В Python-приложениях: 
     - Всегда использовать Sentinel/Cluster-клиенты для прозрачного failover, с retry-логикой и timeouts.

---

Этот блок подчеркивает, что базовая репликация — фундамент, но для настоящей высокой доступности нужен 
- Sentinel (для простых случаев) 
- или Cluster (для масштаба). 



