# Введение в Redis

## 1. Определение и ключевые характеристики

**Redis** — это высокопроизводительное in-memory хранилище данных,  
которое может использоваться сразу в нескольких ролях:

* как **кэш**;
* как **key–value база данных**;
* как **брокер сообщений** (Pub/Sub);
* как **временное хранилище** для координации и realtime-данных.

### 1.1. Redis как кэш

**Что это значит?**

Redis хранит копии данных, которые есть в другом, более медленном источнике:
* SQL-база (PostgreSQL, MySQL)
* внешний API 
* файловая система

**Цель** — ускорить доступ и снизить нагрузку на основной источник.

**Типичный сценарий**

* Приложение запрашивает данные
* Сначала проверяет Redis
* Если данные есть → сразу возвращает
* Если нет → идёт в основную БД, кладёт результат в Redis с **TTL** (Time To Live)

**Особенности**

* Данные не являются источником истины
* Часто используется TTL (время жизни ключей)
* Потеря Redis не критична (кэш можно восстановить)

**Когда использовать?**

* Часто читаемые данные
* Дорогие запросы
* Высокая нагрузка на чтение

---

### 1.2. Redis как база данных

**Что это значит?**

Redis используется как основное хранилище данных, а не как копия.

**Данные:**

* имеют бизнес-смысл 
* должны сохраняться 
* могут реплицироваться и бэкапиться

**Особенности**

* Redis становится `source of truth`
* Используются механизмы **персистентности** (данным не страшны ни отключение питания, ни рестарт):
  * RDB (снимки)
  * AOF (журнал команд)
* TTL может быть, но не обязателен

**Когда использовать?**

* Сессии
* Корзины
* Счётчики 
* Простые модели данных с высокой скоростью

---

### 1.3. Redis как брокер сообщений (Pub/Sub)

**Что это значит?**

Redis используется для передачи событий между компонентами системы.

* Издатель (publisher):
  * отправляет сообщение в канал 
* Подписчик (subscriber):
  * получает сообщение в момент публикации

**Важное ограничение**

* Redis не хранит сообщения:
  * если подписчик был офлайн — сообщение потеряно

**Подписчики:**

* WebSocket-сервер 
* сервис нотификаций 
* логгер

**Когда использовать?**

* Realtime-уведомления 
* Чаты 
* Обновления UI 
* Лёгкая event-шина

---

### 1.4. Redis как временное хранилище для координации и realtime-данных

**Что это значит?**

Redis используется как распределённый координационный слой между сервисами.

**Он помогает:**

* синхронизировать процессы
* управлять состояниями
* работать с данными «здесь и сейчас»

**Типичные задачи**

* Distributed locks 
* Rate limiting 
* Очереди 
* Presence (кто онлайн)

**Особенности**

* Данные короткоживущие 
* Часто используется атомарность команд Redis 
* Высокая конкуренция на доступ

---

### 1.5. Сводная таблица ролей

| Роль                   | Источник истины | Хранение   | Потеря данных      | TTL          | Основной фокус |
| ---------------------- | --------------- | ---------- | ------------------ | ------------ | -------------- |
| Кэш                    | ❌ нет           | временное  | допустима          | почти всегда | скорость       |
| Key–Value БД           | ✅ да            | постоянное | критична           | опционально  | данные         |
| Pub/Sub                | ❌ нет           | не хранит  | сообщения теряются | нет          | события        |
| Координация / realtime | ❌ нет           | временное  | допустима          | часто        | синхронизация  |


## 2. Ключевая особенность Redis 

Это — хранение данных **в оперативной памяти (RAM)**.  

За счёт этого он обеспечивает очень высокую скорость работы:  
* в типичных сценариях — **сотни тысяч и даже миллионы операций в секунду** на одном экземпляре.

При этом Redis остаётся:

* простым по модели данных;
* универсальным по сценариям применения;
* удобным для интеграции с backend-приложениями.

### Redis и персистентность

Хотя Redis ориентирован на RAM, он **не является чисто volatile-хранилищем**. Он поддерживает:

* снапшоты данных (RDB),
* журналирование операций (AOF),
* комбинированные режимы.

Тем не менее, важно понимать философию Redis:

> **Redis оптимизирует скорость, а не долговременное хранение данных.**

Персистентность здесь — опциональная и **вторичная** по отношению к производительности.

---

## 3. Отличия Redis от традиционных СУБД

Если сравнивать Redis с классическими SQL-СУБД (MySQL, PostgreSQL), различия принципиальны:

| Критерий           | Redis        | Традиционные SQL-СУБД    |
| ------------------ | ------------ | ------------------------ |
| Основное хранилище | RAM          | Диск                     |
| Схема данных       | Нет схемы    | Строгая схема            |
| JOIN               | Нет          | Есть                     |
| Транзакции         | Ограниченные | Полноценные              |
| Основной фокус     | Скорость     | Надёжность и целостность |

Redis **не предназначен** для замены основной базы данных.  
Его задача — **дополнять** её, снимая нагрузку и ускоряя доступ к данным.

---

## 4. Роли Redis в приложениях

На практике Redis используется в приложениях в нескольких типовых ролях.

### 4.1. Кэширование

Самый распространённый сценарий:

* кеширование результатов SQL-запросов;
* кеширование ответов API;
* кеширование данных от внешних сервисов.

В FastAPI это особенно актуально, так как:

* фреймворк сам по себе быстрый;
* бутылочным горлышком часто становится БД или внешние API.

Redis позволяет существенно снизить latency без усложнения архитектуры.

---

### 4.2. Хранилище сессий и токенов

Redis часто используют для:

* хранения user-сессий;
* хранения refresh-токенов;
* blacklisting JWT.

Преимущества:

* TTL “из коробки”;
* быстрый доступ;
* простая очистка устаревших данных.

---

### 4.3. Очереди и фоновые задачи

С помощью списков и atomic-операций Redis может выступать:

* простой очередью задач;
* промежуточным хранилищем для background-воркеров.

Хотя Redis не заменяет специализированные брокеры (RabbitMQ, Kafka),  
для многих backend-задач его возможностей достаточно.

---

### 4.4. Realtime-данные

Redis подходит для:

* счётчиков;
* метрик;
* лайков;
* статусов “онлайн/оффлайн”.

То есть там, где:

* данные часто обновляются,
* допустима потеря части состояния,
* важна скорость.

---

## 5. Redis в Python-проектах

В Python Redis чаще всего используется **в связке с основной БД**:

* SQL (PostgreSQL, MySQL),
* реже — с NoSQL (т.к. у них больше сходства с Redis)

Типичная архитектура:

```
FastAPI → Redis (кэш / сессии / лимиты)
        → SQL БД (основные данные)
```

Redis не вытесняет БД, а **разгружает её**.

---

## 6. История и экосистема Redis

Redis — проект с открытым исходным кодом, начатый в 2009 году.  
Он активно развивается и имеет большое сообщество, что выражается в:

* стабильности протокола,
* большом количестве клиентов,
* обилии документации и практик.

### Redis-клиенты для Python

Основной и рекомендуемый клиент сегодня:

* **`redis-py`**

Он поддерживает:

* синхронный API,
* асинхронный API (`redis.asyncio`),
* connection pooling,
* Pub/Sub.

Важно уточнение:

> Библиотека **aioredis** считается устаревшей и **включена в redis-py**, отдельное использование больше не рекомендуется.

---

## 7. Преимущества Redis для Python-разработчиков

Для Python-разработчиков Redis особенно удобен по нескольким причинам:

* простая модель данных (без ORM);
* минимальный порог входа;
* отличная интеграция с:

  * **FastAPI**,
  * **Django**,
  * asyncio;
  
* поддержка async без сложных абстракций;
* лёгкое масштабирование за счёт выноса state из приложения.

Для FastAPI это особенно важно, так как:

* приложение часто stateless;
* Redis становится внешним быстрым state-хранилищем.

