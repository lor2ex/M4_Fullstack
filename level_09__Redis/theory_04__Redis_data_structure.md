Этот блок посвящён теоретическому обзору пяти базовых структур данных Redis.  

- Строки (Strings)
- Списки (Lists)
- Множества (Sets)
- Хэши (Hashes)
- Отсортированные множества (`Sorted Sets` / `ZSets`)

Каждая структура рассмотрена с точки зрения 

- внутренней реализации, 
- ключевых характеристик, 
- операций 
- и типичных сценариев применения.

---

### Основные структуры данных в Redis

#### 1. Строки (Strings)

- **Сущность**: 
  - Самый простой и универсальный тип данных в Redis. 
  - Значение строки может быть 
    - текстом, 
    - сериализованным объектом (JSON, MessagePack), 
    - целым числом 
    - или бинарными данными.
    
- **Ограничения**: 
  - Максимальный размер одного значения — 512 МБ.
  
- **Ключевые возможности**:
  - Атомарные операции инкремента/декремента (`INCR`, `INCRBY`, `DECR` и др.).
  - Битовые операции (`SETBIT`, `GETBIT`, `BITCOUNT`) — эффективное хранение и обработка битовых массивов.
  - Операции над подстроками (`GETRANGE`, `SETRANGE`, `APPEND`).
  
- **Типичные применения в Python**:
  - Счётчики (просмотры страниц, лайки).
  - Кэширование строковых данных (результаты API, HTML-фрагменты).
  - Хранение сериализованных объектов (`json.dumps()`).
  - Bloom-фильтры и другие вероятностные структуры на базе битовых операций.

---

#### 2. Списки (Lists)

> **Двусвязный список** — это структура данных, которая состоит из узлов (nodes), где каждый узел хранит:
> * Значение (данные)
> * Ссылку на следующий узел (next)
> * Ссылку на предыдущий узел (prev)  
> 
> То есть каждый элемент "связан" и с предыдущим, и с последующим элементом.

- **Внутренняя реализация**: 
  - Двусвязный список (`linked list`) или `ziplist` 
  - (компактное представление для малого количества элементов).
  
- **Характеристики**: 
  - Упорядоченная коллекция элементов, допускающая дубликаты. 
  - Доступ по индексу `O(N)`, но операции на концах списка — `O(1)`.
  
- **Ключевые операции**:
  - Добавление: `LPUSH`, `RPUSH`.
  - Извлечение: `LPOP`, `RPOP`.
  - Блокирующие версии: `BLPOP`, `BRPOP` — ожидание элемента при пустом списке.
  - Доступ по индексу: `LINDEX`, `LRANGE`.
  - Обрезка: `LTRIM`.

- **Типичные применения в Python**:
  - Очереди задач (`task queue`) — классический producer-consumer.
  - Стек (`LIFO`) или очередь (`FIFO`).
  - Хранение последних N элементов (лог событий, чат-сообщения).
  - Реализация простых очередей без внешних библиотек вроде `RQ` или `Celery`.

---

#### 3. Множества (Sets)

- **Внутренняя реализация**: 
  - Хэш-таблица (для больших множеств) или `intset` (для небольших множеств целых чисел).

- **Характеристики**: 
  - Неупорядоченная коллекция уникальных элементов. 
  - Все операции (добавление, проверка, удаление) — O(1) в среднем.
  
- **Ключевые операции**:
  - Добавление/удаление: `SADD`, `SREM.`
  - Проверка принадлежности: `SISMEMBER`.
  - Математические операции: 
    - `SINTER` (пересечение), 
    - `SUNION` (объединение), 
    - `SDIFF` (разность).
  - Случайный элемент: `SRANDMEMBER`, `SPOP`.

- **Типичные применения в Python**:
  - Хранение уникальных элементов (список тегов, подписчики).
  - Операции над множествами (поиск общих друзей, рекомендации).
  - Лотереи и рандомизация (`SPOP/SRANDMEMBER`).

---

#### 4. Хэши (Hashes)

- **Внутренняя реализация**: 
  - Хэш-таблица или `ziplist` (для малого количества полей).

- **Характеристики**: 
  - Карта «поле → значение» внутри одного ключа Redis. 
  - Позволяет хранить объект как набор полей, экономя память по сравнению с отдельными ключами.

- **Ключевые операции**:
  - Установка/получение полей: `HSET`, `HGET`, `HMSET`, `HMGET`.
  - Получение всех полей: `HGETALL`, `HKEYS`, `HVALS`.
  - Атомарный инкремент поля: `HINCRBY`.
  - Проверка существования поля: `HEXISTS`.

- **Типичные применения в Python**:
  - Хранение объектов (пользователь, товар, сессия) вместо сериализации в строку.
  - Частичное обновление объектов без перезаписи всего значения.
  - Кэширование записей из реляционной БД.

---

#### 5. Отсортированные множества (`Sorted Sets` / `ZSets`)
- **Внутренняя реализация**: 
  - Skip list + хэш-таблица (для быстрого поиска по элементу и по рангу).

- **Характеристики**: 
  - Коллекция уникальных элементов (member), 
    - каждый из которых имеет числовой балл (score). 
  - Автоматическая сортировка по баллу, 
  - возможность одинаковых баллов.
  
- **Ключевые операции**:
  - Добавление/обновление: `ZADD`.
  - Получение по рангу: `ZRANGE`, `ZREVRANGE`.
  - Получение по баллу: `ZRANGEBYSCORE`, `ZREVRANGEBYSCORE`.
  - Удаление: `ZREM`, `ZREMRANGEBYRANK`, `ZREMRANGEBYSCORE`.
  - Получение ранга/балла: `ZRANK`, `ZSCORE`.
  - Атомарный инкремент балла: `ZINCRBY`.

- **Типичные применения в Python**:
  - Лидерборды (`рейтинги игроков`).
  - Очереди с приоритетом (`priority queue`).
  - Временные ряды (`score = timestamp`).
  - Кэши с политикой eviction по рангу.

---

#### Таблица сравнения базовых структур данных

| Структура              | Тип коллекции                  | Уникальность элементов | Упорядоченность                  | Основные операции (сложность)                  | Внутренняя реализация (оптимизации)                  | Типичные сценарии применения в Python-приложениях |
|-----------------------|--------------------------------|------------------------|----------------------------------|-----------------------------------------------|-----------------------------------------------------|--------------------------------------------------|
| **Строки (Strings)**   | Простое значение               | —                      | —                                | SET/GET/INCR/DECR (O(1))<br>SETBIT/GETBIT (O(1)) | Простая строка или raw bytes                        | Счётчики, кэширование результатов, сериализованные объекты (JSON), битовые массивы |
| **Списки (Lists)**     | Упорядоченная последовательность | Допускает дубликаты    | По порядку вставки                | LPUSH/RPUSH/LPOP/RPOP (O(1))<br>LINDEX/LRANGE (O(N)) | Двусвязный список или ziplist (для малых списков)   | Очереди задач (FIFO/LIFO), последние N элементов, логи событий, чат-сообщения |
| **Множества (Sets)**   | Неупорядоченная коллекция      | Только уникальные      | Нет                              | SADD/SREM/SISMEMBER (O(1))<br>SINTER/SUNION/SDIFF (O(N)) | Хэш-таблица или intset (для малых множеств целых чисел) | Уникальные списки (теги, подписчики), операции над множествами, рандомизация |
| **Хэши (Hashes)**      | Карта «поле → значение»        | Уникальные поля        | Нет                              | HSET/HGET/HINCRBY (O(1))<br>HGETALL (O(N))     | Хэш-таблица или ziplist (для малого количества полей) | Хранение объектов (пользователь, товар), частичные обновления, кэширование записей БД |
| **Отсортированные множества (Sorted Sets / ZSets)** | Коллекция с баллами (score) | Только уникальные члены | По возрастанию/убыванию балла    | ZADD/ZRANGE/ZINCRBY (O(log N))<br>ZRANGEBYSCORE (O(log N + M)) | Skip list + хэш-таблица                             | Лидерборды, очереди с приоритетом, временные ряды (score = timestamp), кэш с eviction по рангу |

#### Краткие пояснения к таблице
- **Сложность операций**: 
  - Указана средняя/худшая сложность для наиболее частых операций. 
  - Redis оптимизирует быстрые операции на уровне O(1) или O(log N).

- **Внутренняя реализация**: 
  - Redis автоматически выбирает компактные структуры (`ziplist`, `intset`) 
    - (при малом объёме данных для экономии памяти) 
  - и переходит на полноценные структуры при росте.

- **Выбор структуры**: 
  - Зависит от требований к 
    - уникальности, 
    - порядку, 
    - сложности доступа 
    - и типу операций. 
  - Правильный выбор структуры критически влияет на производительность и потребление памяти.

---

Этот блок даёт полное теоретическое понимание того, как 
- Redis хранит и обрабатывает данные разных типов,  
- и почему он (для определённых задач) значительно эффективнее традиционных баз данных.