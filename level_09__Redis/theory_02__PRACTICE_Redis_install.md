Существует 2 способа установки Redis:

1. **Нативная установка** (через пакетный менеджер ОС)
2. **Запуск в контейнере (Docker)**


## 1. Сравнение способов установки Redis

| Критерий                    | Нативная установка             | Docker-контейнер                |
| --------------------------- | ------------------------------ | ------------------------------- |
| Что это                     | Redis установлен напрямую в ОС | Redis запускается как контейнер |
| Поддерживаемые ОС           | Linux, macOS                   | Любая ОС с Docker               |
| Сложность установки         | Низкая                         | Средняя (нужен Docker)          |
| Воспроизводимость окружения | Низкая                         | Высокая                         |
| Совпадение dev / prod       | Часто разное                   | Почти идентичное                |
| Управление версиями Redis   | Через ОС                       | Через тег образа                |
| Изоляция                    | Отсутствует                    | Полная                          |
| Конфигурация                | Файлы в системе                | Через volume / env              |
| Обновление Redis            | Через пакетный менеджер        | `docker pull`                   |
| Риск конфликтов             | Возможен                       | Практически отсутствует         |
| Подходит для обучения       | Да                             | Да                              |
| Подходит для команды        | Плохо                          | Да                              |
| Подходит для production     | Ограниченно                    | Да                              |
| Типичный выбор              | Локальные эксперименты         | FastAPI-проекты                 |

---

**Таким образом:**  
Нативная установка полезна для знакомства с Redis,  
но **в реальных FastAPI-проектах почти всегда выбирают контейнер**.  

---

## 2. Нативная установка Redis

### 2.1. Установка на Linux

На большинстве Linux-дистрибутивов Redis доступен через пакетный менеджер.

**Ubuntu / Debian:**

```bash
sudo apt update
sudo apt install redis-server
```

После установки Redis обычно:

* запускается автоматически,
* слушает `localhost:6379`.

Проверить статус:

```bash
sudo systemctl status redis
```

Запуск и остановка:

```bash
sudo systemctl start redis
sudo systemctl stop redis
```

---

### 2.2. Установка на macOS

На macOS наиболее простой способ — **Homebrew**.

```bash
brew update
brew install redis
```

Запуск сервиса:

```bash
brew services start redis
```

Или ручной запуск:

```bash
redis-server
```

---

## 3. Запуск Redis через Docker (рекомендуемый вариант)

Для FastAPI-проектов Docker — самый удобный и воспроизводимый способ.

### Быстрый запуск

```bash
docker run -d --name redis -p 6379:6379 redis:latest
```

Что здесь происходит:

* используется официальный образ Redis (последний);
* порт 6379 пробрасывается на localhost;
* Redis запускается в фоне.

---

### 3.1. Проверка, что контейнер работает

```bash
docker ps
```

В списке должен появиться контейнер `redis`.

---

## 4. Redis в docker-compose

### 4.1. Вариант учебного проекта

Типичный `docker-compose.yml` для учебного backend-проекта:

```yaml
services:
  redis:
    image: redis:latest
    ports:
      - "6379:6379"
```

1. `image: redis:latest` — официальный образ Redis с Docker Hub.
2. `ports: "6379:6379"` — проброс порта контейнера на хост, чтобы к Redis можно было подключиться снаружи 
   * (например, `redis-cli -h localhost -p 6379`).
   * но предварительно на машине должен быть установлен `redis-tools`
    ```bash
    sudo apt update
    sudo apt install redis-tools
    ```

Этот минимальный вариант **запустит Redis в режиме по умолчанию**:
* без пароля, 
* без персистентности (данные будут жить только в памяти контейнера) 
* и с конфигурацией по умолчанию.

⚠️ Ограничения такого подхода

1. **Нет персистентности**: 
   * если контейнер остановится — все данные пропадут.
   * Чтобы включить сохранение, нужно монтировать volume и/или включить AOF/RDB через конфиг.

2. **Нет пароля**:
   * подключиться может любой, кто видит порт. 
   * Для продакшена обязательно настроить `requirepass`.

3. **Нет настройки конфигурации**: 
   * если нужны лимиты памяти, логирование или кластеры
     * нужно добавлять `command:` 
     * или монтировать файл конфигурации.

---

### 4.2. Вариант Production

```yaml
services:
  redis:
    image: redis:latest
    container_name: redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data         # персистентность данных
    command: [
      "redis-server",
      "--appendonly", "yes",      # включаем AOF для сохранения данных
      "--requirepass", "MyStrongPass123"  # задаём пароль
    ]
    restart: unless-stopped       # автоматически перезапускать контейнер

volumes:
  redis_data:
```

---


1. **Персистентность**

   * `volumes: redis_data:/data` сохраняет данные на хосте, чтобы они не потерялись при перезапуске контейнера.
   * `--appendonly yes` включает **AOF**, который логирует все операции записи для восстановления после сбоя.

2. **Безопасность**

   * `--requirepass "MyStrongPass123"` защищает Redis паролем.
   * Никогда не оставляй пустой пароль в продакшене!

3. **Надёжность**

   * `restart: unless-stopped` перезапускает контейнер при падениях.

4. **Простота подключения**

   * Порт 6379 проброшен на хост, можно использовать `redis-cli -h localhost -p 6379 -a MyStrongPass123`.

---


## 5. Базовая проверка через `redis-cli`

После установки важно убедиться, что Redis действительно отвечает.

### 5.1. Подключение к Redis

```bash
redis-cli --version
```
Правильным ответом будет что-то воде этого:
```
redis-cli 7.0.15
```

А если Redis запущен, но пакет `redis-tools` не установлен, появится что-то вроде:

```bash
Command 'redis-cli' not found, but can be installed with:
sudo apt install redis-tools          # version 5:7.0.15-1ubuntu0.24.04.2, or
sudo apt install valkey-redis-compat  # version 7.2.11+dfsg1-0ubuntu0.2
```

**Установка пакета:**

```bash
sudo apt update
sudo apt install redis-tools
```


Если Redis запущен, а `redis-tools` , то появится приглашение:

```
127.0.0.1:6379>
```

---

### 5.2. Проверка связи

Запускаем:
```bash
redis-cli -h localhost -p 6379
```

И проверяем:

```redis
PING
```

Ожидаемый ответ:

```
PONG
```

---

### 5.3. Простейшие операции

```redis
SET test_key "hello"
GET test_key
```

Ответ:

```
"hello"
```

Удаление:

```redis
DEL test_key
```

---

### 5.4. Проверка TTL

```bash
SET temp "value" EX 30
TTL temp  # покажет число оставшихся секунд жизни ключа

GET temp  # если время не истекло, то покажет значение "value"

```

Через 30 секунд ключ исчезнет.

---

### 6. Если мнение, что Redis имеет смысл ТОЛЬКО при использовании в контейнера приложения

Это не так потому, что это:

1. Кэш в отдельном контейнере всё равно быстро обращения к БД: 
   * операции чтения/записи занимают ~0.1 мс (примерно в 100 раз быстрее БД). 
   
2. Обеспечивает общий кэш для всех сервисов: 
   * все контейнеры приложения обращаются к одному Redis, 
   * в отличие от встроенного кэша, который хранится отдельно в каждом инстансе, 
     * что может приводить к рассинхронизации данных.

3. Упрощает инвалидацию и управление TTL: 
   * Redis сам удаляет устаревшие ключи, без необходимости писать фоновые джобы или таймеры.

4. Легко масштабируется и деплоится: 
   * контейнер Redis одинаково работает в dev, stage и prod; 
   * масштабирование — простое добавление реплик.

5. Повышает надёжность: 
   * можно настроить сохранение данных (RDB/AOF) и репликацию, 
   * чего нет у простого in-memory кэша приложения, который теряет все данные при перезапуске.

6. Минимизирует сложность кода: 
   * кэширование вынесено из приложения, 
   * меньше багов, 
   * меньше зависимостей.

7. Контроль памяти и переполнение:
   * Redis хранит данные в RAM, поэтому при большом объёме кэша можно столкнуться с переполнением.
   * Если Redis запущен в отдельном контейнере, то 
     * его падение или переполнение не крашит основное приложение, 
     * а память ограничена контейнером, что позволяет:
       * выделять больше RAM для кэша,
       * проще контролировать расход ресурсов.
   * Это даёт безопасное разграничение ресурсов между кэшем и сервисом.