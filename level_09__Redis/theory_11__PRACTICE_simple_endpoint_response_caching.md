### Простое кэширование ответа эндпойнта

Усложним задачу.  
Создадим эндпойнт, который работу с помощью кэширования в Radis «тяжёлых» операций:
* Если данных в кэше — возвращаются именно эти данные
* Если данных в кэше нет:
  * Выполняется запрос к БД (в нашем случае задержка 1 сек)
  * Полученные данные сохраняются в кэше на время `CACHE_LIFETIME`
  * И возвращаются клиенту

```python
# Демонстрация кэша с "тяжёлой" операцией
@app.get("/cached-data/{item_id}")
async def get_data(item_id: int, client: Redis = Depends(get_redis)):
    start = time.time()

    cache_key = f"data:{item_id}"

    # 1. Сначала проверяем кэш
    cached = await client.get(cache_key)
    print('cached', cached)
    if cached:

        # Добавляем данные о времени и месте выполнения запроса
        updated_cache = json.loads(cached)
        ttl_seconds = await client.ttl(cache_key)
        end = time.time()
        updated_cache.update({
            "Данные": f"Данные взяты из кэша и будут там в течении {ttl_seconds} сек.",
            "Время выполнения:": f'{end - start:.3f}'
        })
        return updated_cache

    # 2. Имитируем тяжелую операцию (например, запрос к БД или API)
    print("Вычисляем данные заново")
    await asyncio.sleep(1)  # задержка для демонстрации

    data = {"item_id": item_id, "name": f"Товар {item_id}", "price": 100 * item_id}

    # 3. Сохраняем результат в кэш на 60 секунд
    await client.set(cache_key, json.dumps(data, ensure_ascii=False), ex=CACHE_LIFETIME)

    # Добавляем данные о времени и месте выполнения запроса
    end = time.time()
    data.update({
        "Данные": f"Данные вычислены заново и сохранены в кэше на {CACHE_LIFETIME} секунд",
        "Время выполнения:": f'{end - start:.3f}'
    })

    return data
```


### Пошаговая логика работы

#### 1. Входные параметры

* **`item_id`** (int) — идентификатор товара, передаётся в URL.
* **`client`** — Redis-клиент, получаемый через `Depends(get_redis)`.

---

#### 2. Фиксация времени начала выполнения

```python
start = time.time()
```

Используется для измерения времени обработки запроса.

---

#### 3. Формирование ключа кэша

```python
cache_key = f"data:{item_id}"
```

Для каждого `item_id` используется свой ключ в Redis.

---

#### 4. Проверка наличия данных в кэше

```python
cached = await client.get(cache_key)
```

##### Если данные **есть в кэше**:

* Данные извлекаются из Redis.
* Преобразуются из JSON в словарь.
* Получается оставшееся время жизни ключа (`TTL`).
* Чтобы не переключаться в терминал, в словарь ответа добавляется информация:

  * о том, что данные взяты из кэша;
  * оставшееся время жизни кэша;
  * время выполнения запроса.
* **Тяжёлая операция не выполняется**.
* Ответ возвращается сразу.

---

#### 5. Если данных нет в кэше

```python
await asyncio.sleep(1)
```

* Имитируется тяжёлая операция (например, запрос к БД).
* Создаётся объект данных товара.
* Данные сохраняются в кэш.
* Устанавливается время жизни (`CACHE_LIFETIME`, например 60 секунд).

---

#### 6. Формирование финального ответа

* Чтобы не переключаться в терминал, в словарь ответа добавляется информация:

  * что данные вычислены заново;
  * на сколько секунд они сохранены в кэше;
  * сколько времени заняло выполнение запроса.
* Данные возвращаются клиенту.

---

### Примеры запросов и ответов

#### 1. Первый запрос (данных в кэше нет)

[http://127.0.0.1:8000/cached-data/1](http://127.0.0.1:8000/cached-data/1)

**Ответ:**

```json
{
  "item_id": 1,
  "name": "Товар 1",
  "price": 100,
  "Данные": "Данные вычислены заново и сохранены в кэше на 30 секунд",
  "Время выполнения:": "1.003"
}
```

⚡ Запрос обрабатывается долго, так как данные приходится получать из БД.


---

#### 2. Повторный запрос (данные берутся из кэша)

[http://127.0.0.1:8000/cached-data/1](http://127.0.0.1:8000/cached-data/1)

**Ответ:**

```json
{
  "item_id": 2,
  "name": "Товар 2",
  "price": 200,
  "Данные": "Данные взяты из кэша и будут там в течении 23 сек.",
  "Время выполнения:": "0.002"
}
```

⚡ Запрос обрабатывается значительно быстрее, так как данные получены из Redis.

---

#### 3. Запрос после истечения TTL

Если подождать, пока истечёт `CACHE_LIFETIME`, и снова выполнить запрос:

[http://127.0.0.1:8000/cached-data/1](http://127.0.0.1:8000/cached-data/1)


Поведение будет аналогично **первому запросу** — данные будут вычислены заново и снова сохранены в кэше.

**Ответ:**

```json
{
  "item_id": 1,
  "name": "Товар 1",
  "price": 100,
  "Данные": "Данные вычислены заново и сохранены в кэше на 30 секунд",
  "Время выполнения:": "1.003"
}
```

---

### Выводы

Эндпойнт:

* демонстрирует **паттерн cache-aside**;
* уменьшает нагрузку на систему;
* ускоряет повторные запросы;
* наглядно показывает разницу во времени выполнения.

