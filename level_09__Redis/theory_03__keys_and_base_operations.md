Этот блок посвящен фундаментальным аспектам работы с ключами в Redis: 
* их природе, 
* ограничениям, 
* базовым операциям по манипуляции данными, 
* механизмам истечения срока жизни (TTL), 
* а также инструментам для групповой обработки команд — транзакциям и пайплайнам. 

---

### Ключи и базовые операции

#### Концепция ключей

- **Ключи как строки**:
  * В Redis все ключи являются строками (strings). 
  * Точнее — последовательностями байтов (binary-safe strings). 
  * Длина ключа известна заранее (передается в протоколе), 
    * поэтому нулевые байты (\0) или другие специальные символы не прерывают строку.
    
- **Бинарная безопасность (binary safety)**: 
  * Ключи (и строковые значения) в Redis полностью бинарно-безопасны. 
    * (могут содержать любые байты от 0 до 255 без необходимости эскейпинга или преобразования)  
  
- **Ограничения на размер**: 
  * Максимальный размер ключа — **512 МБ** (по умолчанию). 
    * (конфигурируется параметром `proto-max-bulk-len` и применяется как к ключам, так и к строковым значениям)
 
- **Пространства имен (namespaces)**: 
  - Redis не имеет встроенных пространств имен, 
  - но общепринятая конвенция — использовать двоеточие (:) для логического разделения. Примеры:  
    - `user:123` — данные пользователя с `ID` 123;  
    - `session:abcdef` — сессия;  
    - `cache:api:endpoint:v1` — кэш для API.  

Это упрощает управление и поиск ключей (например, через `KEYS user:*`), но не влияет на производительность.

#### Базовые операции

Основные команды для работы с ключами (независимо от типа значения):
- **SET** — Установка значения по ключу. 
  - Перезаписывает существующее значение (даже если тип отличается). 
  - Поддерживает опции: 
    - `NX` (set only if not exists), 
    - `XX` (set only if exists), 
    - `EX/ PX` (expiration in seconds/milliseconds), 
    - `KEEPTTL` (сохранить существующий TTL), 
    - `GET` (вернуть старое значение).
    
- **GET** — Получение значения по ключу. 
  - Возвращает nil, если ключ не существует или значение не строка.
  
- **DEL** — Удаление одного или нескольких ключей. 
  - Возвращает количество фактически удаленных ключей (игнорирует несуществующие).
  
- **EXISTS** — Проверка существования одного или нескольких ключей. 
  - Возвращает количество существующих.

#### TTL (time-to-live) — автоматическое удаление ключей
- **Концепция**: 
  - Ключи могут быть "volatile" (с TTL) — Redis автоматически удалит их по истечении срока. 
  - Это полезно для кэша, сессий, временных данных.
  
- **Основные команды**:
  - **EXPIRE key seconds** — Установить TTL в секундах.
  - **PEXPIRE key milliseconds** — В миллисекундах (более точный).
  - **EXPIREAT / PEXPIREAT** — Установить абсолютное время истечения (Unix timestamp).
  - **TTL / PTTL** — Вернуть оставшееся время (в секундах/миллисекундах; -2 если ключ не существует, -1 если без TTL).
  - **PERSIST** — Убрать TTL, сделать ключ постоянным.
  
- Если TTL ≤ 0 — ключ удаляется немедленно. 
- TTL работает независимо от типа значения.

#### Транзакции 

- **Транзакции (`MULTI/EXEC`)**:  
  - Обеспечивают **атомарность** и **изоляцию** последовательности команд:  

    - `MULTI`**` — Начало транзакции (команды ставятся в очередь, возвращают "QUEUED").  
    - Команды внутри — выполняются последовательно без прерывания другими клиентами.  
    - `EXEC` — Выполнить все queued команды атомарно (все или ничего).  
    - `DISCARD` — Отменить транзакцию.  
  
  - ⚠️ Важное отличие от транзакций в реляционных БД:
    - Транзакции не поддерживают rollback (как в RDBMS) — 
      - если команда внутри ошибочна, предыдущие выполнятся, последующие нет.
    - Таким образом, в Redis транзакция
      - атомарна по запуску (запускаются либо все, либо ни одна)
      - НО НЕ атомарна по результату 
      - Вывод: в битве между
        - возможностью `rollback` 
        - и сохранением высокой скорости 
          - победила скорость.
          - (иначе пришлось бы где-то хранить старые значения, 
          - чтобы знать куда "откатить" при неудачной транзакции).
 
  - **`WATCH key [key ...]`** — Оптимистичная блокировка (`optimistic locking`): 
    - мониторит ключи до EXEC. 
      - Если хотя бы один изменился другим клиентом — вся транзакция отменяется (`EXEC` возвращает `nil`). 
    - Используется для реализации `check-and-set` (CAS) операций, например, атомарного INCR.

#### Пайплайны

- **Пайплайны (`pipelining`)**:  

  - **Не транзакция, а оптимизация сети**: 
    - клиент отправляет несколько команд одним пакетом без ожидания ответов на промежуточные. 
    - Сервер выполняет их последовательно и возвращает все ответы разом.  
    
  - **Преимущества**: 
    - снижает latency (RTT) и overhead системных вызовов 
    - в разы повышает throughput (особенно при высоком RTT).  
  
  - **Нет гарантии атомарности**:
    - команды могут перемежаться с командами других клиентов.  
  
  - **В Python `redis-py`**: 
    - пайплайн создается автоматически для батч-операций или явно через `pipeline()`.

#### Python-перспектива (redis-py)

Язык Redis — это что-то вроде своего собственного SQL, насчитывающий около 200 команд.  
(сравнение грубое, но на уровне идеи - точное)  
Поэтому Python-перспектива — чем-то сродни Python API для работы с SQL БД.

- Ключи обрабатываются как **bytes** по умолчанию (для бинарной безопасности). 
  - (При `decode_responses=True` — как str, => теряют свою бинарную безопасность)
- Основные методы клиента:
  - `client.set(key, value, ex=seconds, px=milliseconds, nx=True, xx=True, get=True)` — гибкий аналог SET.
  - `client.get(key)` — возвращает bytes/str или None.
  - `client.delete(*keys)` — аналог DEL.
  - `client.exists(*keys)` — количество существующих.
  - `client.expire(key, seconds)` — устанавливает время жизни ключа key в секундах.
  - `client.pexpire(key, ms)` — то же самое, что expire, но время указывается в миллисекундах.
  - `client.ttl(key)` — возвращает оставшееся время жизни ключа в секундах
  
- **Транзакции**: 
  - `with client.pipeline(transaction=True) as pipe: ... pipe.execute()`. 
  - Или `client.multi()` + `client.execute()`.
  
- **WATCH**: 
  - `client.watch(*keys)`, 
  - затем pipeline с transaction=True.

- **Пайплайны**: 
  - `with client.pipeline() as pipe: ... results = pipe.execute()` — автоматически батчит команды.

---

Этот блок закладывает основу для понимания всех остальных структур данных Redis,  
поскольку все операции начинаются с работы с ключами. 
