Этот блок посвящён теоретическим аспектам сохранения данных в Redis.  
Как известно Redis позиционируется как in-memory хранилище.  
Однако Redis предоставляет механизмы, позволяющие 
- сохранять данные на диск 
- и восстанавливать их после перезапуска. 

---

### Персистентность и долговечность данных в Redis

> **Персистентность** в Redis — это компромисс между скоростью записи и гарантией сохранности данных.

#### 1. Основная дилемма Redis: скорость vs долговечность

- Redis хранит все данные в оперативной памяти для максимальной скорости.
- Без дополнительных механизмов при перезапуске сервера или сбое процесса все данные теряются.
- Redis предлагает два независимых механизма персистентности, 
  - которые можно использовать по отдельности или вместе.

---

#### 2. RDB (Redis Database Backup) — снимки (snapshots)

- **Сущность**: 
  - Периодическое создание `point-in-time` снимка всей базы данных в один момент времени.

- **Механизм работы**:
  - Redis форкает процесс (`copy-on-write`), 
  - дочерний процесс записывает текущее состояние памяти в файл `.rdb`.
  - Основной процесс продолжает обслуживать запросы без блокировки.

- **Конфигурация** (параметры в `redis.conf`):
  - `save 900 1` — сохранить, если за 900 секунд произошло минимум 1 изменение.
  - `save 60 10000` — сохранить, если за 60 секунд произошло минимум 10 000 изменений.
  - `save ""` — полностью отключить RDB.

- **Преимущества**:
  - Компактный файл (данные сжимаются).
  - Быстрое восстановление (один файл загружается целиком).
  - Минимальное влияние на производительность в обычном режиме.

- **Недостатки**:
  - Возможна потеря данных: 
    - все изменения между снимками теряются при краше.
  - Форк может быть дорогим на системах с большим объёмом памяти (копирование `page table`).

- **Применение в Python-контексте**: 
  - Подходит для кэша, сессий, где допустима потеря последних минут данных.

---

#### 3. AOF (Append-Only File) — журнал операций

- **Сущность**: 
  - Запись каждой команды записи в лог-файл в том порядке, в котором она была выполнена.

- **Механизм работы**:
  - Каждая команда, изменяющая данные (SET, DEL, INCR и т.д.), аппендится в файл `.appendonly.aof`.
  - При перезапуске Redis последовательно воспроизводит (replay) все команды из лога.

- **Политики сброса на диск (`fsync`)**:
  - `appendfsync always` — `fsync` после каждой команды. 
    - Максимальная долговечность, но сильное падение производительности.
  - `appendfsync everysec` — `fsync` каждую секунду (по умолчанию). 
    - Компромисс: возможна потеря максимум 1 секунды данных.
  - `appendfsync no` — полагается на ОС. 
    - Максимальная скорость, но риск потери данных при краше.

- **Преимущества**:
  - Высокая долговечность (при `always` — потеря данных практически невозможна).
  - Лог легко читать и понимать (текстовый формат команд RESP).


- **Недостатки**:
  - Файл AOF значительно больше RDB.
  - Восстановление медленнее (нужно выполнить все команды заново).

- **Переписывание `AOF` (`BGREWRITEAOF`)**:
  - Периодический процесс, который перестраивает AOF в минимальный набор команд, 
    - эквивалентный текущему состоянию данных.
  - Запускается автоматически при превышении порога роста файла или вручную.

- **Применение в Python-контексте**:
  - Рекомендуется для критически важных данных (например, финансовые транзакции, очереди задач).

---

#### 4. Гибридный режим (RDB + AOF)

- Начиная с Redis 7 по умолчанию включены оба механизма.

- При восстановлении:
  - Сначала загружается RDB-снимок (быстрое восстановление основного объёма).
  - Затем воспроизводятся команды из AOF, произошедшие после последнего снимка.

- Обеспечивает лучший баланс: 
  - быстрый старт + минимальная потеря данных.

---

#### 5. Сравнение RDB и AOF

| Характеристика              | RDB                          | AOF                              |
|-----------------------------|------------------------------|----------------------------------|
| Потеря данных при краше     | До последнего снимка         | До последнего `fsync`              |
| Размер файла на диске       | Меньше (сжатие)               | Больше                           |
| Скорость восстановления     | Быстрее                      | Медленнее                        |
| Влияние на производительность | Низкое (кроме момента форка) | Зависит от fsync-политики        |
| Читаемость файла            | Бинарный                     | Текстовый (команды)              |
| Подходит для                | Кэш, сессии, некритичные данные | Критичные данные, очереди        |

---

#### 6. Рекомендации для Python-разработчиков

- Для кэширования (FastAPI + Redis): 
  - достаточно RDB или даже отключённой персистентности.

- Для хранения сессий пользователей: 
  - RDB с частыми снимками или `AOF everysec`.

- Для очередей задач (RQ, Celery): 
  - обязательно AOF с `fsync everysec` или `always`.

- В production всегда мониторить размер AOF и наличие `BGREWRITEAOF`.

---

Понимание рассмотренных выше механизмов, позволяет осознанно выбирать конфигурацию Redis в зависимости от  
- требований приложения к производительности 
- и надёжности хранения данных.