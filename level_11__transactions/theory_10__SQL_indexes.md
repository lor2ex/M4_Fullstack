
## 1. Типы индексов — в принципе (на уровне БД)

### 1.1 B-Tree (основной и самый важный)

**По умолчанию почти везде.**

**Подходит для:**

* `=`
* `< > <= >=`
* `BETWEEN`
* `ORDER BY`
* `LIKE 'abc%'` (с начала строки)

**Пример:**

```sql
CREATE INDEX idx_user_email ON users(email);
```

**Когда нужен:**

* фильтрация
* сортировка
* JOIN по полю
 
* **90% всех индексов — B-Tree**

> B-Tree поиск использует логарифмический поиск (очень похожий на бинарный).
> Различие:
> Бинарный поиск предполагает:
> * одномерный массив
> * доступ по индексу O(1)
> * деление диапазона строго на две части
> 
> B-Tree:
> * это дерево, а не массив
> * каждый узел может иметь десятки или сотни потомков
> * переход идёт между страницами, а не по индексам массива
>
> Но B-Tree и бинарный поиск похожи на каждом уровне бинарного дерева, где
>
> На каждом уровне дерева:
> * ключи в узле отсортированы
> * внутри узла может применяться линейный или бинарный поиск по ключам
> * глубина дерева мала → поиск O(log N)
>
> То есть:
> * внутри узла — иногда бинарный поиск
> * по структуре в целом — многопутевой поиск, а не бинарный
> 

---

### 1.2 Hash (редко используется)

**Только для `=`**, без диапазонов.

* PostgreSQL: почти не используется
* MySQL: под капотом всё равно B-Tree

> Обычно **не нужен**, B-Tree справляется лучше.

---

### 1.3 Composite (составной индекс)

Индекс по **нескольким колонкам**.

```sql
CREATE INDEX idx_order_user_date ON orders(user_id, created_at);
```

**Правило левого префикса:**
* B-Tree индекс используется только начиная с левого (первого) столбца индекса.

```sql
WHERE user_id = 5           
WHERE user_id = 5 AND created_at > '2024-01-01' 
WHERE created_at > '2024-01-01' 
```

---

### 1.4 Unique индекс

Гарантирует уникальность **+ ускоряет поиск**.

```sql
CREATE UNIQUE INDEX idx_user_email ON users(email);
```

Используется для:

* логинов
* email
* business-ключей

---

### 1.5 Partial / Filtered индекс (PostgreSQL)

Индекс **только для части данных**.

```sql
CREATE INDEX idx_active_users ON users(id)
WHERE is_active = true;
```

**Удачно подходит для:**

* soft delete ("мягкое удаление")
* статусов
* флагов

---

### 1.6 Functional индекс

Индекс на выражение.

```sql
CREATE INDEX idx_lower_email ON users(LOWER(email));
```

Нужен если в запросах:

```sql
WHERE LOWER(email) = 'test@mail.com'
```

---

### 1.7 Full-Text

Для текстового поиска:

* PostgreSQL: `GIN + tsvector`
* MySQL: `FULLTEXT`

❗ **не заменяет обычные индексы**


---

## 2. Оптимизация с помощью ключей

## 2.1 PRIMARY KEY

```sql
PRIMARY KEY (id)
```

Это:

* уникальность
* NOT NULL
* **автоматический индекс**

**Самый быстрый способ найти строку**

В SQLAlchemy:

```python
id = Column(Integer, primary_key=True)
```

---

## 2.2 FOREIGN KEY — скрытая оптимизация JOIN

```sql
FOREIGN KEY (user_id) REFERENCES users(id)
```

❗ **Но важный момент** 
**Foreign Key сам по себе НЕ создаёт индекс** (PostgreSQL, MySQL).

Поэтому правильно:

```sql
CREATE INDEX idx_orders_user_id ON orders(user_id);
```

В SQLAlchemy:

```python
user_id = Column(ForeignKey("users.id"), index=True)
```

**Это критично для:**

* JOIN
* каскадных операций
* подзапросов

---


## Всегда помним главное правило оптимизации:

> **Индексы ускоряют чтение, но замедляют запись**

Поэтому:

* не индексируйте всё подряд
* индекс → под конкретный запрос
* всегда проверяйте `EXPLAIN`

