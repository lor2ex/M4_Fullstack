При работе SQLAlchemy c `asyncpg` неверное значение параметра `lazy` в `relationship()`  
может принести крайне неприятные сюрпризы.

---

### Чем хорош `lazy` в обычном (sync) SQLAlchemy?

**Что он делает**

* Не грузит связанные данные сразу
* "Ходит" в БД **только когда есть реальное обращение к полю**

**Почему это удобно**

* Меньше запросов, если связь не нужна
* Простой код: читаешь поле — оно работает
* Можно читать данные **когда угодно**, пока есть сессия

**Ключевое**

> В sync-режиме ORM **может незаметно сходить в БД** в любой момент.

---

### И чем `lazy` плох в async SQLAlchemy?

Ровно тем же — своей попыткой "незаметно сходить в БД"!

**Почему это ломается**

* В async **нельзя** делать запрос без `await`
* После выхода из `async with session:`:

  * соединение закрыто
  * `await` невозможен
* ORM пытается сходить в БД → и возвращает ошибку: `MissingGreenlet`

> «Нет зелёного потока (greenlet), в котором разрешено делать async-I/O»

**Ключевое**

> `lazy` может попытаться сделать запрос
> **после завершения async-контекста**, где запросы запрещены.

---

### Рекомендация при использовании asyncpg для SQLAlchemy 2.0+:

| lazy значение          | Что происходит в async режиме                                                                                                                          | Рекомендация для asyncpg / FastAPI                          | Когда использовать |
|-----------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------|---------------------|
| `lazy="select"`       | По умолчанию. При обращении к связи → пытается сделать SELECT → <br>может привести к ошибке **MissingGreenlet** (если сессия закрыта или нет greenlet) | **Не используйте** по умолчанию                              | Почти никогда      |
| `lazy="raise"`        | При обращении к связи → сразу кидает `InvalidRequestError` (даже если сессия открыта)                                                                  | Полезно для отладки / предотвращения ошибок                 | В моделях по умолчанию + отладка |
| `lazy="raise_on_sql"` | Аналогично `raise`, но более точное сообщение (в новых версиях)                                                                                        | Хороший дефолт в async-проектах                             | Часто как дефолт   |
| `lazy="noload"`       | Связь не загружается вообще, при обращении → `None` или пустой список (без ошибки)                                                                     | **Очень часто** — самый безопасный вариант в production     | Когда не хотите случайных запросов |
| `lazy="selectin"`     | `lazy loader` с batch-поведением, для `eager loading` надо добавить `joinedload() / selectinload()` в `.options()` запроса                             | **Хорошо работает** в async, но используйте через `.options(selectinload())` в запросах | Когда нужна коллекция почти всегда |
| `lazy="joined"`       | JOIN в основном запросе                                                                                                                                | **Хорошо работает** в async, но может раздуть запрос        | Для one-to-one / часто нужных связей |
| `lazy="subquery"`     | Подзапрос для загрузки коллекции                                                                                                                       | Работает, но обычно хуже производительности чем selectin    | Редко              |

### Самые популярные и рекомендуемые подходы в async (FastAPI + asyncpg)

1. **Самый безопасный и популярный в 2025–2026**  
   В моделях:

   ```python
   class Book(Base):
       genres: Mapped[list[Genre]] = relationship(
           secondary="book_genres",
           back_populates="books",
           lazy="noload",              # или "raise"
           cascade="delete"
       )
   ```

   В запросах чтения **всегда** используйте явную подгрузку:

   ```python
   stmt = (
       select(Book)
       .options(
           selectinload(Book.genres),
           selectinload(Book.detail),
           selectinload(Book.author)
       )
   )
   ```

   Это полностью исключает `MissingGreenlet` и случайные запросы.

2. **Обязательная настройка сессии** (чтобы избежать большинства проблем) `expire_on_commit=False`

   ```python
   AsyncSessionLocal = async_sessionmaker(
       engine,
       class_=AsyncSession,
       expire_on_commit=False,     # критически важно❗
       autoflush=False,
   )
   ```

### Таким образом при asyncpg параметр `lazy` лучше сделать:

- **В production / API** → `lazy="noload"` или `lazy="raise"` (или `raise_on_sql`)  
  + всегда явный `selectinload` / `joinedload` в запросах
- **Не оставляйте** `lazy="select"` (или дефолт) — это почти гарантированная ошибка в будущем

