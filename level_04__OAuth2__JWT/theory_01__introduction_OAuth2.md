## Что такое OAuth 2.0?

**OAuth 2.0** — это протокол авторизации (не аутентификации!),  
который позволяет одному сервису  
получить доступ к данным пользователя в другом сервисе **без передачи пароля**.


---

## История OAuth

### OAuth 1.0 (2007)

* Был первым стандартом.
* Использовал **криптографические подписи** для проверки запросов.
* Был **сложным**: каждый запрос нужно было подписывать (HMAC, RSA).
* Работал через **тяжёлый и запутанный** процесс.

### OAuth 2.0 (2012)

* Это **не улучшенная версия**, а **почти новый протокол**.
* Упрощён:

  * вместо подписей — **HTTPS** для защиты;
  * вместо сложных подписи — **короткоживущие токены**.
* Гораздо удобнее для веба, мобильных и SPA-клиентов.
* Но... **менее безопасен**, если использовать неправильно.

⚠️ **Важно:** OAuth 2.0 *не обратно совместим* с 1.0.
Это разные протоколы, просто с похожими задачами.

---

##  Основная идея `OAuth2.0 `

OAuth2.0 — это **протокол делегированного доступа**.
Он описывает, *как стороннее приложение (клиент) может получить доступ*
к данным пользователя, которые находятся на другом сервере.

`OAuth2.0` определяет:

* роли участников,
* форматы запросов,
* типы грантов (grant types) — способы получения токена,
* стандартные эндпойнты авторизационного сервера
  (`/authorize`, `/token`).

`JWT` — это *лишь один из способов* упаковать данные в access token.
`OAuth2.0` не требует `JWT` (может быть opaque token и т.д.).

---

### Роли участников

1. **Resource Owner** — пользователь (тот, чьи данные защищены).
2. **Client** — приложение, которое хочет получить доступ.
3. **Authorization Server** — выдает токены.
4. **Resource Server** — хранит защищённые данные и проверяет токены.

---

### Поток авторизации (`Authorization Code Grant`)

Это *основной и самый безопасный* поток OAuth2:

1. **Resource Owner** (пользователь) выбирает: «Войти / Разрешить доступ».

2. **Client** перенаправляет пользователя на **Authorization Server**, передавая:

   * `client_id`
   * `redirect_uri`
   * `scope`
   * `state`
   * `code_challenge` (PKCE — для публичных клиентов)

3. **Authorization Server** показывает пользователю экран согласия.

4. **Пользователь** подтверждает доступ.

5. Авторизационный сервер делает redirect на `redirect_uri` клиента
   и передает **authorization code**.

6. **Client Backend** отправляет запрос на `/token`:

   ```
   grant_type=authorization_code
   code=...
   redirect_uri=...
   client_id=...
   client_secret=...
   (или code_verifier — для PKCE)
   ```
   **PKCE** (`Proof Key for Code Exchange` / «доказательство владения ключом для обмена кодом») —  
   это усиление безопасности OAuth2 для публичных клиентов  
   (мобильных приложений, SPA, настольных программ), которые не могут хранить `client_secret`.

7. **Authorization Server** отвечает:

   * `access_token`
   * `refresh_token` (если запрошен)
   * `expires_in`
   * `token_type=bearer`

8. **Client** использует `access_token`, чтобы обращаться к **Resource Server**.

---

### `Types of Grants` (когда какой поток используется)

`OAuth2.0` определяет несколько способов получения токена.  

#### 1) Authorization Code Grant

* Используется веб-приложениями и мобильными приложениями.
* Самый безопасный вариант (особенно с PKCE).

#### 2) Implicit Grant (устарел)

* Использовался для SPA, но сейчас считается небезопасным.

#### 3) Resource Owner Password Credentials (ROPC / Password Grant)

* Пользователь вводит логин/пароль *прямо в клиенте*.  
* Используется только для **внутренних систем**, и никогда для публичных клиентов.

(⚠️ Далее в нашем примере как раз будет использован **Password Grant**).

#### 4) Client Credentials Grant

* Применяется для сервис-сервис взаимодействия.  
* Нет пользователя — есть только клиент.

Пример: бэкенд запрашивает токен у другого сервиса.

#### 5) Refresh Token

* Не поток авторизации, но важный механизм:
* позволяет получать новый access token без участия пользователя.

---

### Основные типы токенов

#### `Access Token`

* короткоживущий
* предъявляется ресурсному серверу
* может быть JWT или opaque

#### `Refresh Token`

* живёт долго
* хранится *только на backend*
* не передаётся в браузер (если SPA — только через httpOnly cookie)

---

### Аутентификация ≠ Авторизация

* `OAuth2.0` **не определяет аутентификацию**.
* Он определяет *делегированный доступ*.

Если есть задача «Войти через Google»,
это уже не OAuth2, а **OpenID Connect (OIDC)** —
надстройка над OAuth2.

OIDC добавляет:

* identity token (ID Token — это JWT)
* userinfo endpoint
* стандартный способ получения данных пользователя

---

## Сравнение Grant Types в OAuth2.0

| Grant Type                                                   | Когда используется                                             | Участники                                              | Риск безопасности                                                                     | Пример                                                 |
|--------------------------------------------------------------|----------------------------------------------------------------| ------------------------------------------------------ | ------------------------------------------------------------------------------------- | ------------------------------------------------------ |
| **Authorization Code Grant**                                 | Веб-приложения, мобильные приложения                           | User → Client → Authorization Server → Resource Server | ✅ Высокая безопасность, особенно с PKCE                                               | Войти через Google/Facebook на сайте                   |
| **Implicit Grant** *(устарел)*                               | SPA (одностраничные приложения)                                | User → Client → Authorization Server → Resource Server | ⚠️ Меньше безопасности, токен сразу в браузер                                         | Старые SPA приложения                                  |
| **Resource Owner Password Credentials <br>(Password Grant)** | Внутренние приложения, доверенные клиенты <br>(**наш пример**) | User → Client → Authorization Server → Resource Server | ⚠️ Пользователь передаёт пароль напрямую клиенту, не безопасно для публичных клиентов | FastAPI пример с `/token` и логином/паролем            |
| **Client Credentials Grant**                                 | Сервис-сервис взаимодействие                                   | Client → Authorization Server → Resource Server        | ✅ Безопасно, нет пользователя                                                         | Backend микросервис получает токен для обращения к API |
| **Refresh Token**                                            | Для продления доступа без участия пользователя                 | Client → Authorization Server → Resource Server        | ⚠️ Нужно безопасно хранить на backend                                                 | Любой поток, чтобы обновить access token               |

---

**Примечания**

1. **Authorization Code + PKCE** — рекомендуемый поток для SPA и мобильных приложений.
2. **Password Grant** — только для внутренних систем, где клиент полностью доверен.
3. **Implicit Grant** устарел и почти не используется.
4. **Refresh Token** не самостоятельный грант, а **механизм продления access token**.
5. **JWT** может использоваться внутри любого гранта как формат токена.


