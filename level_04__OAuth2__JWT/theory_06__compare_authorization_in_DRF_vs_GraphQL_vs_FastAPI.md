## Сравнение OAuth2.0 и обычного JWT

Сравним авторизацию, которую мы использовали в DRF, GraphQL 
с тем, что сейчас используем в FastAPI.

И главный вопрос: 
* Когда был простой `JWT`, а когда —` OAuth2.0?`

---

## 1. Обычный `JWT` vs `OAuth2.0`

### Обычный JWT

— это просто способ подписать данные (`user_id`, `expires` и т.д.).
Он никак не определяет:

* как клиент получает токен
* как проходит аутентификация
* как сервер выдаёт токены

Всё это мы придумываем сами.

### `OAuth2.0`

— это *протокол*, который строго определяет:

* как клиент получает токен (`grant types`)
* какие форматы запросов
* какие ответы
* как выглядит процесс выдачи токена
* как клиент должен отправлять токен в запросах

JWT может использоваться `внутри OAuth2`, но не является им.

---

## 2. Сравнение трёх известных нам технологий REST API

### ✔ Проект 1: `DRF + JWT`

❌ **OAuth2 — НЕ используется**
✔ **JWT — используется**

Что происходит?

```
POST /api/token/
{
  "email": "...",
  "password": "..."
}
```

Мы:

* сами описывали эндпойнт
* сами передавали JSON
* эта схема никак не относится к `OAuth2.0`

Это называется:

> “Выдача JWT вручную по собственному API”.

---

### ✔ Проект 2: `GraphQL + JWT`

❌ **OAuth2 — нет**
✔ **JWT — есть**

GraphQL:

```
mutation {
  tokenAuth(email:"...", password:"...")
}
```

Мы даже не выполнили POST /token в "оаутовском" стиле —
а просто вызывали GraphQL-мутацию.

Это снова:

> “Произвольная схема выдачи JWT”
> (даже не REST, а чистый GraphQL).

---

## ✔ Проект 3: `FastAPI + OAuth2PasswordRequestForm`

✔ **OAuth2 — используется**
✔ **JWT — используется как format токена**

Здесь ключевое отличие:

Мы впервые используем встроенную реализацию OAuth2.0 Password Grant,  
пусть и частично реализованную с помощью JWT.

Это видно по форме запроса:

```
Content-Type: application/x-www-form-urlencoded

username=demo
password=secret
grant_type=password
```

И по эндпойнту:

```
POST /token
```

Это уже структура `OAuth2 Authorization Server`, а не самодельная схема.

JWT в этом проекте — это **внутренний способ формировать токен**,
но процесс его выдачи соответствует OAuth2.

---

### 3. Ключевое различие между проектами (и подходами)

| Проект      | Использование обычного JWT | Использование OAuth2  |
| ----------- | -------------------------- | --------------------- |
| **DRF**     | ✔ Да                       | ❌ Нет                 |
| **GraphQL** | ✔ Да                       | ❌ Нет                 |
| **FastAPI** | ✔ Да (внутри OAuth2)       | ✔ Да (Password Grant) |

---

## Резюме

### В DRF и GraphQL:

* `JWT` выдаётся произвольным способом
* `OAuth2` никаких правил не задаёт
* форматы запросов вы придумали сами
* грантов нет
* нет `tokenUrl`, нет схемы `OAuth2`

Это **просто JWT**, не `OAuth2`.

### В FastAPI:

* `JWT` создаётся после прохождения `OAuth2 Password Grant`
* есть строго определённый эндпойнт `/token`
* есть строго определённая форма `OAuth2PasswordRequestForm`
* есть `security dependency`, который реализует `OAuth2 Bearer Token` проверку

Это **настоящий OAuth2 Authorization Server**, пусть и сильно упрощённый.
