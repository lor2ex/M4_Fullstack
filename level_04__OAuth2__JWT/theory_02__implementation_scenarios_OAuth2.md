## Сценарии реализации OAuth2

### Ключевая идея

**JWT = формат токена.**
**OAuth2.0 = протокол получения токена.**

Поэтому, строя свою систему (например, API на FastAPI), мы сами становимся:

* авторизационным сервером,
* и ресурсным сервером —   
  (если только мы не разделяем их физически).
* а клиент — это тот, кто делает API запрос к ресурсному серверу 

---

### Сценарий 1: Всё в одном приложении (типичный FastAPI + JWT)

* `/token` выдаёт JWT после проверки логина и пароля.
* Остальные эндпоинты `/users/me`, `/items/...` защищены токеном.

В этом случае:

#### ✔ Авторизационный сервер (Authorization Server)

**Наш собственный backend** (тот же FastAPI).

Он делает:

* проверку логина/пароля,
* формирует JWT,
* подписывает JWT,
* отдаёт токен пользователю.

Это endpoint обычно называется `/token`.

#### ✔ Ресурсный сервер (Resource Server)

**Тоже наш backend**.

Это те эндпойнты, куда пользователь стучится с токеном:

* `/users/me`
* `/orders`
* `/items`
* `/admin`
* и т.д.

То есть один и тот же сервер выполняет две роли.

#### ✔ Клиент

Любое приложение, которое делает запросы к нашему API, например:
* мобильное приложение
* фронтенд (`React/Vue`)
* `Postman`/`Insomnia`
* другой backend-сервис
* просто пользователь через `curl`

Так выглядит 99% учебных и практических реализаций FastAPI.

---

#### Сценарий 2: Разделение на два сервера (более зрелая архитектура)

Если мы разделяем архитектуру:

* Один сервис отвечает за **аутентификацию** и выдачу JWT.
* Другой — хранит реальные данные.

Тогда:

#### ✔ Авторизационный сервер

Сервис А, например:

```
auth.mycompany.com
```

Он:

* принимает логин/пароль,
* выдаёт JWT,
* обновляет токены (refresh),
* хранит ключи подписи (private key),
* отдаёт public key для проверки.

#### ✔ Ресурсный сервер

Сервис Б, например:

```
api.mycompany.com
```

Он:

* принимает JWT от клиента,
* проверяет подпись токена (через public key),
* отдаёт защищённые данные.

#### ✔ Клиент — ТРЕТЬЕ приложение, которое обращается к API

То есть:
**Клиент = тот, кто хочет получить доступ к данным на ресурсном сервере.**

Им может быть:
* `SPA`-фронтенд (`React`, `Vue`, `Angular`)
* мобильное приложение (`iOS`/`Android`)
* наш собственный микро-сервис
* desktop-приложение
* `Postman`/`Insomnia`
* просто `curl`

То есть клиент НЕ является частью двух серверов (Авторизационного и ресурсного).  
Он является **внешним** по отношению к ним.
---

### Сценарий 3: Использование внешнего провайдера (Google, GitHub, Keycloak)

Тогда:

* Авторизационный сервер — **Google**
* Ресурсный сервер — **Google API**
* наш сервер выступает в роли клиента по отношению к внешнему авторизационному и ресурсному серверу

Но в этом случае **JWT может быть внешним**, а мы просто его просто принимаем.



