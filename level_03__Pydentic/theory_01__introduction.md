### Что такое Pydantic?

**Pydantic** — это Python-пакет для валидации данных и их строгой типизации.  
Он позволяет описывать структуру данных с помощью аннотаций типов (как в обычных Python-классах),  
а затем автоматически проверять входные данные и преобразовывать их к нужным типам.


Автор пакета **Сэмюэль Колвин (Samuel Colvin)**.  
Первые стабильные версии появились примерно в **2017–2018 годах**  
и быстро стали стандартом де-факто для валидации данных в Python, особенно в веб-фреймворках.

---

### Что может Pydantic?

Pydantic решает несколько задач:

#### ✔ 1. Строгая валидация данных**

* Он принимает любые входные структуры (словари, JSON, вложенные данные), 
* проверяет их соответствие типам и правилам:
  * и либо возвращает корректный объект, 
  * либо выдаёт человекопонятную ошибку.
* Валидация работает рекурсивно: 
  * вложенные модели, списки, словари — всё проверяется до последнего уровня.

#### ✔ 2. Автоматическое преобразование типов

Pydantic умеет "умно" приводить данные:
* строки в числа, 
* строки в datetime, 
* словари в модели, 
* списки в типизированные коллекции.

#### ✔ 3. Работа со схемами

Он может генерировать схемы данных в формате **JSON Schema**, что полезно для документации API.

#### ✔ 4. Удобная сериализация

Любую модель можно легко превратить обратно в словарь или JSON, с учётом правил сериализации.

#### ✔ 5. Высокая скорость

Pydantic v2 (переписанный на основе движка *pydantic-core* на Rust) стал гораздо быстрее и точнее в обработке данных.  
Это одна из причин, почему его широко используют в высоконагруженных API.

---

### Чего Pydantic не может?

Несмотря на богатую функциональность, у него есть ограничения:

#### ✖ 1. Не является ORM

Он не работает напрямую с базами данных и не создаёт SQL-таблицы.  
Он только валидирует данные.

#### ✖ 2. Не заменяет Python-типы

Он использует подсказки типов, но не влияет на сам интерпретатор Python:  
это не runtime-типизация языка, а прослойка на уровне данных.

#### ✖ 3. Не выполняет бизнес-логику

Он может помочь проверить входные данные,  
но не решает задачи бизнес-правил, транзакций или внешних зависимостей.

#### ✖ 4. Не валидирует данные “лениво”

Каждая модель проверяется полностью при создании,  
что иногда создаёт накладные расходы для огромных структур данных.

